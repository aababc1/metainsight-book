{"version":3,"kind":"Article","sha256":"6cb45de8a63d10f700906ec567c7314431465c79166774549896c48eab6e49f1","slug":"denovo-assembly","location":"/metagenomics/Denovo_assembly.md","dependencies":[],"frontmatter":{"title":"De novo assembly","content_includes_title":false,"authors":[{"nameParsed":{"literal":"META-Insight Team","given":"META-Insight","family":"Team"},"name":"META-Insight Team","id":"contributors-myst-generated-uid-0"}],"github":"https://github.com/aababc1/metainsight-book","keywords":["metagenomics","metatranscriptomics","metaproteomics","microbiome","bioinformatics"],"numbering":{"title":{"offset":1}},"source_url":"https://github.com/aababc1/metainsight-book/blob/main/metagenomics/Denovo_assembly.md","edit_url":"https://github.com/aababc1/metainsight-book/edit/main/metagenomics/Denovo_assembly.md","thumbnail":"/metainsight-book/build/030715b7a3310134807a1e7844273e01.png","exports":[{"format":"md","filename":"Denovo_assembly.md","url":"/metainsight-book/build/Denovo_assembly-69f903989fae0aa05f3020f08d2978b5.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"container","children":[{"type":"image","style":{"width":"90%"},"url":"/metainsight-book/build/030715b7a3310134807a1e7844273e01.png","alt":"","data":{"altTextIsAutoGenerated":true},"key":"hdWI0E0w3d","urlSource":"https://github.com/sujin9819/MetaInsight/blob/main/SOP/MetaGenomic/img/G_7_1.png?raw=true"},{"type":"caption","children":[{"type":"paragraph","children":[{"type":"strong","children":[],"key":"jMC6G1b98Q"}],"key":"HggJB007zq"}],"key":"IOv9nzFDfg"}],"enumerator":"1","key":"CgcX3v64ru"},{"type":"heading","depth":2,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Short reads","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"teIAKKrYl5"}],"identifier":"short-reads","label":"Short reads","html_id":"short-reads","implicit":true,"key":"fo6yFYl7WQ"},{"type":"paragraph","position":{"start":{"line":8,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Read-based profiling offers a rapid overview of the metagenome but is limited by the presence of a significant number of unmapped reads.\nTo overcome this limitation, de novo assembly is employed using assemblers to extend overlapping reads into contigs or scaffolds.\nThis approach enables in-depth profiling of genomic components and the discovery of previously unknown sequences since it is a database-independent process.","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"JnHFM2VgJA"}],"key":"bOdPafbiiX"},{"type":"paragraph","position":{"start":{"line":12,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"text","value":"Currently, various assemblers are available. Some assemblers are specifically designed for the efficient assembly of short reads.\nAmong the most widely utilized assemblers, ","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"ZUH2Zfb4k9"},{"type":"link","url":"https://github.com/voutcn/megahit","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"MEGAHIT","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"OJSNje4kOj"}],"urlSource":"https://github.com/voutcn/megahit","error":true,"key":"eeF2MDU0sT"},{"type":"text","value":" and ","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"kAD0KHohqF"},{"type":"link","url":"https://cab.spbu.ru/software/meta-spades/","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"metaSPAdes","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"eNwbNVfGuQ"}],"urlSource":"https://cab.spbu.ru/software/meta-spades/","key":"yndUz7mnzR"},{"type":"text","value":" stand out.\nmetaSPAdes is particularly renowned for its performance with high-depth samples. However, it demands a substantial amount of memory, even for small-sized metagenome data.\nMEGAHIT shows competitive assembly quality and efficient memory usage compared to metaSPAdes. ","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"s8JFDkUBrB"},{"type":"cite","url":"https://doi.org/10.1038/s41596-020-00480-3","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"[ref]","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"iMLlp2BmU2"}],"kind":"narrative","label":"Meyer_2021","identifier":"https://doi.org/10.1038/s41596-020-00480-3","enumerator":"1","key":"LrYgF48XGE"},{"type":"text","value":".","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"THKDfDJTqX"}],"key":"jzDWckbVYQ"},{"type":"paragraph","position":{"start":{"line":17,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"text","value":"MEGAHIT employs k-mers, and the size of these k-mers can be adjusted based on the sample’s complexity using the ","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"MnJYOUs99R"},{"type":"inlineCode","value":"--k-min","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"m8JXpqYEJi"},{"type":"text","value":" and ","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"SrTAiYfXII"},{"type":"inlineCode","value":"--k-max","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"sIu8G7DSJG"},{"type":"text","value":" options.\nWhen dealing with high-depth samples, it is advisable to select a relatively larger k-mer size (typically 25-31) to prevent excessive complexity in the de Bruijn graph.\nConversely, for low-depth samples where the assembly isn’t functioning optimally, you can enhance assembly efficiency by employing the ","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"lACmEOZV70"},{"type":"inlineCode","value":"--no-mercy","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"BwKYlLWQzf"},{"type":"text","value":" option.\nFor paired-end reads, make sure to specify the forward and reverse read filenames separately using ","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"j1ZbWAQc7j"},{"type":"inlineCode","value":"-1","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"hrX6i8Geci"},{"type":"text","value":" and ","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"iXtPVIWhfo"},{"type":"inlineCode","value":"-2.","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"KTk5ns5H47"},{"type":"text","value":" For single reads, use the ","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"g9IS7iYNBW"},{"type":"inlineCode","value":"-r","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"CWRIUFqkCA"},{"type":"text","value":" option.\nThe maximum memory allocated for de Bruijn graph construction can be set using the ","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"N2CgmvsGqG"},{"type":"inlineCode","value":"-m","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"nZo5x4NOaq"},{"type":"text","value":" option and the total system memory can be adjusted within the range of 0-1.\nThe default value is typically set to 0.9. The ","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"LAvYtPNNHG"},{"type":"inlineCode","value":"-t","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"edSDc2Zl1B"},{"type":"text","value":" option allows you to define the number of CPU threads, with a minimum requirement of 2.\nBy default, the software automatically calculates the available CPU threads and utilizes them collectively.","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"l3BjrMHb4a"}],"key":"VlIxBmpXYR"},{"type":"code","lang":"bash","value":"# run MEGAHIT \n$ conda activate MEGAHIT\n$ MEGAHIT -1 kneaddata.trimmed.1.fastq  -2 kneaddata.trimmed.2.fastq  -m 0.5  -t 12 -o MEGAHIT_result\n$ conda deactivate","position":{"start":{"line":25,"column":1},"end":{"line":30,"column":1}},"key":"pe0X52eMnR"},{"type":"heading","depth":2,"position":{"start":{"line":32,"column":1},"end":{"line":32,"column":1}},"children":[{"type":"text","value":"Long reads assembly","position":{"start":{"line":32,"column":1},"end":{"line":32,"column":1}},"key":"UCqpM1muZn"}],"identifier":"long-reads-assembly","label":"Long reads assembly","html_id":"long-reads-assembly","implicit":true,"key":"JTmwp9WfiY"},{"type":"paragraph","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"children":[{"type":"text","value":"PacBio HiFi long reads (typically 10–20 kb with >99% accuracy) enable the resolution of repetitive genomic regions and the recovery of near-complete metagenome-assembled genomes that are inaccessible through short-read assembly alone. The assembler ","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"key":"lTJkQhFtL8"},{"type":"link","url":"https://github.com/lh3/hifiasm-meta","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"children":[{"type":"text","value":"hifiasm-meta","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"key":"khOFbmrsYO"}],"urlSource":"https://github.com/lh3/hifiasm-meta","error":true,"key":"JEbod86nMC"},{"type":"text","value":" is specifically designed for metagenomic HiFi data, producing high-quality primary and alternate contigs by leveraging the length and accuracy of HiFi reads to resolve strain-level haplotypes within complex microbial communities. Unlike short-read assemblers based on de Bruijn graphs, hifiasm-meta uses an overlap-based approach that better preserves long-range genomic structure.","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"key":"wnijKCnFd5"}],"key":"ES36OxOePO"},{"type":"code","lang":"bash","value":"# run hifiasm_meta \n$ conda activate hifiam_meta\n$ hifiasm_meta -o N14.asm -t 60 N14.aln.unmapped.fq > N14.log\n$ conda deactivate\n# .gfa 파일을 .fa 파일로 변환\n$ awk '/^S/{print \">\"$2;print $3}' test.p_ctg.gfa > test.p_ctg.fa","position":{"start":{"line":36,"column":1},"end":{"line":43,"column":1}},"key":"p1DpcVlVsN"},{"type":"paragraph","position":{"start":{"line":45,"column":1},"end":{"line":48,"column":1}},"children":[{"type":"text","value":"“.gfa” stands for graphical fragment assembly, a file format designed to store graph-based assembly information.\nIt contains data about the graph generated during the assembly process.\nThe structure of the graph file is akin to a de Bruijn graph, illustrating the connectivity of nodes and edges.\nThese graphs depict the interactions among overlapping DNA sequences, aiding in the assembly process.","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"key":"OzShUdKOEL"}],"key":"JP6WXZYMsv"},{"type":"paragraph","position":{"start":{"line":50,"column":1},"end":{"line":50,"column":1}},"children":[{"type":"text","value":"When running ","position":{"start":{"line":50,"column":1},"end":{"line":50,"column":1}},"key":"BuD04meC7b"},{"type":"link","url":"https://github.com/lh3/hifiasm-meta","position":{"start":{"line":50,"column":1},"end":{"line":50,"column":1}},"children":[{"type":"text","value":"Hifiasm-meta","position":{"start":{"line":50,"column":1},"end":{"line":50,"column":1}},"key":"bKVU9jY7aV"}],"urlSource":"https://github.com/lh3/hifiasm-meta","error":true,"key":"UmGW5Hdb8b"},{"type":"text","value":", the output files are as follows.","position":{"start":{"line":50,"column":1},"end":{"line":50,"column":1}},"key":"NFuSyagEfg"}],"key":"dizEDwanJN"},{"type":"paragraph","position":{"start":{"line":53,"column":1},"end":{"line":58,"column":1}},"children":[{"type":"strong","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"children":[{"type":"text","value":"1. Raw unitig graph: asm.r_utg*.gfa","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"Ojxj3zsjk8"}],"key":"ClfrBKE5Jp"},{"type":"break","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"aefS3FGBt6"},{"type":"text","value":"This file contains the raw unitig graph generated during the assembly process. The raw unitig graph is the initial graph for assembly, which organizes nodes and edges based on overlapping sequence information.\n","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"omaOiBOZ47"},{"type":"strong","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"children":[{"type":"text","value":"2. Cleaned unitig graph: asm.p_utg*.gfa","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"k2nqBvvkxH"}],"key":"SPh4mbFZ4N"},{"type":"break","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"IzhHCYk7tJ"},{"type":"text","value":"This file contains preprocessed cleaned unitig graphs. Preprocessing refers to the process of removing errors from the raw unitig graph and improving its accuracy.\n","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"ShFLaeNIuc"},{"type":"strong","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"children":[{"type":"text","value":"3. Contig graph: asm.p_ctg*.gfa, asm.a_ctg*.gfa","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"RGEDz4b7Lr"}],"key":"bGl0C5arcN"},{"type":"break","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"HbsjJda9ca"},{"type":"text","value":"This file contains the contig graph. The file asm.p_ctg*.gfa means primary contig and asm.a_ctg*.gfa means alternate contig.","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"W5EKMkIsoQ"}],"key":"tj2iPrYQdZ"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":61,"column":1},"end":{"line":63,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":61,"column":1},"end":{"line":63,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Unitig","position":{"start":{"line":61,"column":1},"end":{"line":61,"column":1}},"key":"UciT9dcecz"},{"type":"break","position":{"start":{"line":61,"column":1},"end":{"line":61,"column":1}},"key":"lPzYUZJi4v"},{"type":"text","value":"A unitig, which stands for unique sequence, is a unit of overlapping DNA sequences that is the result of an intermediate step in assembly. Each unitig consists of one or more DNA sequences and contains overlapping parts. The assembly process generates a raw unitig graph. This raw unitig graph may contain some errors. The subsequent processing removes the errors from the raw unitig graph and generates a cleaned unitig graph.","position":{"start":{"line":61,"column":1},"end":{"line":61,"column":1}},"key":"KJJB7QrDnN"}],"key":"Yo1A2xV2kk"}],"key":"ciFWfWetxE"}],"key":"F1zraDhGJU"},{"type":"heading","depth":2,"position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"children":[{"type":"text","value":"Contig check","position":{"start":{"line":64,"column":1},"end":{"line":64,"column":1}},"key":"wtpgzlsoKs"}],"identifier":"contig-check","label":"Contig check","html_id":"contig-check","implicit":true,"key":"gBPqvZLp4s"},{"type":"paragraph","position":{"start":{"line":65,"column":1},"end":{"line":66,"column":1}},"children":[{"type":"text","value":"Long read assembly results can be visualized using a bandage plot, which is a tool for representing complex assembly results, including De Bruijn graphs or overlap graphs.\nLong read assemblies often yield intricate graphs, and the bandage plot is a good option for visualizing these graphs.","position":{"start":{"line":65,"column":1},"end":{"line":65,"column":1}},"key":"QCwch0Tre0"}],"key":"wWaOeP9uJf"},{"type":"paragraph","position":{"start":{"line":68,"column":1},"end":{"line":68,"column":1}},"children":[{"type":"text","value":"It provides the following information.","position":{"start":{"line":68,"column":1},"end":{"line":68,"column":1}},"key":"cr2HHFDI1z"}],"key":"v6IBw0JFeK"},{"type":"paragraph","position":{"start":{"line":71,"column":1},"end":{"line":71,"column":1}},"children":[{"type":"text","value":"To generate bandage plots, you can use Bandage, a Bioinformatics Application for Navigating De novo Assembly Graphs Easily. Bandage is available for download at ","position":{"start":{"line":71,"column":1},"end":{"line":71,"column":1}},"key":"c5Bt6GV4er"},{"type":"link","url":"http://rrwick.github.io/Bandage/","position":{"start":{"line":71,"column":1},"end":{"line":71,"column":1}},"children":[{"type":"text","value":"http://​rrwick​.github​.io​/Bandage/","position":{"start":{"line":71,"column":1},"end":{"line":71,"column":1}},"key":"pJKu7iPTQn"}],"urlSource":"http://rrwick.github.io/Bandage/","key":"i3uEfOxvHA"},{"type":"text","value":".","position":{"start":{"line":71,"column":1},"end":{"line":71,"column":1}},"key":"nazfVk7yrn"}],"key":"WESLB55maA"},{"type":"paragraph","position":{"start":{"line":74,"column":1},"end":{"line":74,"column":1}},"children":[{"type":"text","value":"After running the Bandage program, load the *p_ctg.gfa file from File > Load graph at the top. Once the file is loaded, click Draw graph in Graph drawing to display the graph.","position":{"start":{"line":74,"column":1},"end":{"line":74,"column":1}},"key":"gjxneBQtJc"}],"key":"Gn97I7Vw7b"},{"type":"container","children":[{"type":"image","style":{"width":"90%"},"url":"/metainsight-book/build/ce209dd902988924d189874ae25587b1.png","alt":"","data":{"altTextIsAutoGenerated":true},"key":"mgjYmJn0TR","urlSource":"https://github.com/sujin9819/MetaInsight/blob/main/SOP/MetaGenomic/img/G_7_2.png?raw=true"},{"type":"caption","children":[{"type":"paragraph","children":[{"type":"strong","children":[],"key":"DPriijdh0X"}],"key":"yNnryElm7J"}],"key":"dQtD1iObBI"}],"enumerator":"2","key":"DjoA2WHHVU"},{"type":"paragraph","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"text","value":"After assembly, check the assembly result and quality using ","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"AaFipgxtsl"},{"type":"link","url":"https://github.com/ablab/quast","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"text","value":"QUAST","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"DHUXqYmJg6"}],"urlSource":"https://github.com/ablab/quast","error":true,"key":"izTAXvKO7k"},{"type":"text","value":"(Quality assessment tool) to know the information of the produced contigs.","position":{"start":{"line":82,"column":1},"end":{"line":82,"column":1}},"key":"r4wC5GptrB"}],"key":"VcOxEfWCyb"},{"type":"code","lang":"bash","value":"# calculate assembly statistics\n$ conda activate quast\n$ quast.py MEGAHIT_result/final.contigs.fa -o MEGAHIT_quast\n$ conda deactivate","position":{"start":{"line":84,"column":1},"end":{"line":89,"column":1}},"key":"skE0oFUoop"},{"type":"container","children":[{"type":"image","style":{"width":"90%"},"url":"/metainsight-book/build/7b78d3d813c18d8e084f529f11c33e7f.png","alt":"Example of report.html","data":{"altTextIsAutoGenerated":true},"key":"Q7hhxiY4vH","urlSource":"https://github.com/sujin9819/MetaInsight/blob/main/SOP/MetaGenomic/img/G_7_3.png?raw=true"},{"type":"caption","children":[{"type":"paragraph","children":[{"type":"strong","children":[{"type":"text","value":"Example of report.html","key":"eo06IHXXBo"}],"key":"qpyLjYceCt"}],"key":"bzsmiiZoRA"}],"key":"jXQ4W0WlyU"}],"enumerator":"3","key":"y8lrtoamnp"},{"type":"paragraph","position":{"start":{"line":97,"column":1},"end":{"line":97,"column":1}},"children":[{"type":"strong","position":{"start":{"line":97,"column":1},"end":{"line":97,"column":1}},"children":[{"type":"text","value":"contigs: Number of contigs produced after assembly","position":{"start":{"line":97,"column":1},"end":{"line":97,"column":1}},"key":"jnq3GhPCOM"}],"key":"yogYWkJfKY"}],"key":"t5SYlb9Ptz"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":98,"column":1},"end":{"line":106,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":98,"column":1},"end":{"line":98,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Largest contig: The length of the longest contig among the contigs produced after assembly","position":{"start":{"line":98,"column":1},"end":{"line":98,"column":1}},"key":"KQxuQZajCr"}],"key":"jt5fyjJ8Uq"}],"key":"ZB6WjV0ODg"},{"type":"listItem","spread":true,"position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Total length: Total number of bases of contigs generated after assembly","position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"key":"HJXNHMnA9H"}],"key":"WfuVsn3Gve"}],"key":"ie45ZjS1MD"},{"type":"listItem","spread":true,"position":{"start":{"line":100,"column":1},"end":{"line":100,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"N50: Length of the contig with the top 50% length among the contigs generated after assembly","position":{"start":{"line":100,"column":1},"end":{"line":100,"column":1}},"key":"RRTgN6wFJK"}],"key":"sruATvOSIe"}],"key":"uxOK0Zan8f"},{"type":"listItem","spread":true,"position":{"start":{"line":101,"column":1},"end":{"line":101,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"N75: Length of the contig with the top 75% length among the contigs generated after assembly","position":{"start":{"line":101,"column":1},"end":{"line":101,"column":1}},"key":"uGaIKvc8mH"}],"key":"iu73xkvzRQ"}],"key":"bvPopj75HG"},{"type":"listItem","spread":true,"position":{"start":{"line":102,"column":1},"end":{"line":102,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"L50: Number of contigs with the length of N50 among the contigs generated after assembly","position":{"start":{"line":102,"column":1},"end":{"line":102,"column":1}},"key":"O4eH6fkOZi"}],"key":"uy4pPj3aU9"}],"key":"dvchODHjT8"},{"type":"listItem","spread":true,"position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"L75: Number of contigs with the length of N75 among the contigs generated after assembly","position":{"start":{"line":103,"column":1},"end":{"line":103,"column":1}},"key":"z7VUWcT68o"}],"key":"X7JrBLf7rS"}],"key":"nLRFxjbnbl"},{"type":"listItem","spread":true,"position":{"start":{"line":104,"column":1},"end":{"line":104,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Mismatches # N’s: Number of uncalled bases that were not assembled","position":{"start":{"line":104,"column":1},"end":{"line":104,"column":1}},"key":"jvZvsvABjJ"}],"key":"jrYA07UnGM"}],"key":"JUe7wjmt4k"},{"type":"listItem","spread":true,"position":{"start":{"line":105,"column":1},"end":{"line":106,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Mismatches # N’s per 100kbp: Number of uncalled bases per 100000 bases","position":{"start":{"line":105,"column":1},"end":{"line":105,"column":1}},"key":"YzvybAbrr9"}],"key":"G3xTSQIMAf"}],"key":"KV9kFdFGK7"}],"key":"J3aUHlQHkY"},{"type":"paragraph","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"children":[{"type":"text","value":"The left Graph shows cumulative length as the contig index increases and the right graph shows GC contents of contigs","position":{"start":{"line":107,"column":1},"end":{"line":107,"column":1}},"key":"v6LsjUAIlM"}],"key":"vXz8TVDAXJ"},{"type":"container","children":[{"type":"image","style":{"width":"90%"},"url":"/metainsight-book/build/eaa6417f1aaec13589a70369854ace71.png","alt":"","data":{"altTextIsAutoGenerated":true},"key":"hPQjtQ765A","urlSource":"https://github.com/sujin9819/MetaInsight/blob/main/SOP/MetaGenomic/img/G_7_4.png?raw=true"},{"type":"caption","children":[{"type":"paragraph","children":[{"type":"strong","children":[],"key":"jQJlaEPxMv"}],"key":"OzTPQtiB94"}],"key":"b4HQV00dmH"}],"enumerator":"4","key":"iACq1LONDc"},{"type":"heading","depth":3,"position":{"start":{"line":113,"column":1},"end":{"line":113,"column":1}},"children":[{"type":"text","value":"References","position":{"start":{"line":113,"column":1},"end":{"line":113,"column":1}},"key":"gnKRaZaNZi"}],"identifier":"references","label":"References","html_id":"references","implicit":true,"key":"XYlma0sDfg"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":115,"column":1},"end":{"line":118,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":115,"column":1},"end":{"line":115,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Li D, Liu CM, Luo R, et al. MEGAHIT: an ultra-fast single-node solution for large and complex metagenomics assembly via succinct de Bruijn graph. ","position":{"start":{"line":115,"column":1},"end":{"line":115,"column":1}},"key":"obP9gvxm2J"},{"type":"emphasis","position":{"start":{"line":115,"column":1},"end":{"line":115,"column":1}},"children":[{"type":"text","value":"Bioinformatics","position":{"start":{"line":115,"column":1},"end":{"line":115,"column":1}},"key":"A3ifWkR5WM"}],"key":"Tg9sxEIIce"},{"type":"text","value":". 2015;31(10):1674-1676. doi:10.1093/bioinformatics/btv033","position":{"start":{"line":115,"column":1},"end":{"line":115,"column":1}},"key":"EIsA3xtg29"}],"key":"RYmbGJRWsb"}],"key":"Lt4uDduZFu"},{"type":"listItem","spread":true,"position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Nurk S, Meleshko D, Korobeynikov A, et al. metaSPAdes: a new versatile metagenomic assembler. ","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"key":"D1D20pXU7H"},{"type":"emphasis","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"children":[{"type":"text","value":"Genome Res","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"key":"YGKvfACn0z"}],"key":"paCsnVqnle"},{"type":"text","value":". 2017;27(5):824-834. doi:10.1101/gr.213959.116","position":{"start":{"line":116,"column":1},"end":{"line":116,"column":1}},"key":"n9DVPi6SCT"}],"key":"Y3GsubQAw2"}],"key":"ySSpBpcEdS"},{"type":"listItem","spread":true,"position":{"start":{"line":117,"column":1},"end":{"line":117,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Feng X, Cheng H, Portik D, et al. Hifiasm: de novo assembly of high-fidelity long reads. ","position":{"start":{"line":117,"column":1},"end":{"line":117,"column":1}},"key":"DFRc8vp5Ol"},{"type":"emphasis","position":{"start":{"line":117,"column":1},"end":{"line":117,"column":1}},"children":[{"type":"text","value":"Nat Methods","position":{"start":{"line":117,"column":1},"end":{"line":117,"column":1}},"key":"s7GtVFFb1L"}],"key":"CIPb2qxfnv"},{"type":"text","value":". 2022;19(6):671-674. doi:10.1038/s41592-022-01478-3","position":{"start":{"line":117,"column":1},"end":{"line":117,"column":1}},"key":"kOoEB5MuSj"}],"key":"mXhBuCUslp"}],"key":"jtK1ZqmDxC"},{"type":"listItem","spread":true,"position":{"start":{"line":118,"column":1},"end":{"line":118,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Gurevich A, Saveliev V, Vyatkin N, et al. QUAST: quality assessment tool for genome assemblies. ","position":{"start":{"line":118,"column":1},"end":{"line":118,"column":1}},"key":"JjvBb3SsMh"},{"type":"emphasis","position":{"start":{"line":118,"column":1},"end":{"line":118,"column":1}},"children":[{"type":"text","value":"Bioinformatics","position":{"start":{"line":118,"column":1},"end":{"line":118,"column":1}},"key":"ftSOPEnSH8"}],"key":"bcCZnqeJZL"},{"type":"text","value":". 2013;29(8):1072-1075. doi:10.1093/bioinformatics/btt086","position":{"start":{"line":118,"column":1},"end":{"line":118,"column":1}},"key":"b2OMjORs05"}],"key":"M5NoCuJZ6n"}],"key":"o66q9NjZsM"}],"key":"OWVx1xUY0y"}],"key":"zKHh2vqfaz"}],"key":"hsbPDQHryl"},"references":{"cite":{"order":["Meyer_2021"],"data":{"Meyer_2021":{"label":"Meyer_2021","enumerator":"1","doi":"10.1038/s41596-020-00480-3","html":"Meyer, F., Lesker, T.-R., Koslicki, D., Fritz, A., Gurevich, A., Darling, A. E., Sczyrba, A., Bremges, A., & McHardy, A. C. (2021). Tutorial: assessing metagenomics software with the CAMI benchmarking toolkit. <i>Nature Protocols</i>, <i>16</i>(4), 1785–1801. <a target=\"_blank\" rel=\"noreferrer\" href=\"https://doi.org/10.1038/s41596-020-00480-3\">10.1038/s41596-020-00480-3</a>","url":"https://doi.org/10.1038/s41596-020-00480-3"}}}},"footer":{"navigation":{"prev":{"title":"Preprocessing of the sequencing reads","url":"/preprocessing","group":"Metagenomics"},"next":{"title":"Binning","url":"/binning","group":"Metagenomics"}}},"domain":"http://localhost:3000"}